/*
 * generated by Xtext
 */
package org.ovirt.engine.permissions.scoping

import com.google.inject.Inject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.ovirt.engine.permissions.SuppressingLinkingResource
import org.ovirt.engine.permissions.permissions.Command

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class PermissionsScopeProvider extends AbstractDeclarativeScopeProvider {
    @Inject
	private TypeReferences typeReferences;
	
   def IScope scope_Permission_objectType(Command ctx, EReference r) {
		return Scopes.scopeFor(SuppressingLinkingResource.objTypes.
			declaredFields,[
			f|QualifiedName.create(f.simpleName)
		], IScope.NULLSCOPE )
	}

	def IScope scope_Permission_actionGroup(Command ctx, EReference r) {
		return Scopes.scopeFor(SuppressingLinkingResource.actionGroups.
			declaredFields,[
			f|QualifiedName.create(f.simpleName)
		], IScope.NULLSCOPE )
	}

    def IScope scope_Permission_condition(Command ctx, EReference r) {
		return Scopes.scopeFor(ctx.type.allFeatures.filter(typeof(JvmOperation)).filter[JvmOperation o|typeReferences.is(o.returnType.type, boolean) && o.parameters.empty],
			[f|QualifiedName.create(f.simpleName)],
			IScope.NULLSCOPE)
	}

    def IScope scope_Permission_objectId(Command ctx, EReference r) {
		return Scopes.scopeFor(ctx.type.allFeatures.filter(typeof(JvmOperation)),
			[f|QualifiedName.create(f.simpleName)],
			IScope.NULLSCOPE)
	}
}
