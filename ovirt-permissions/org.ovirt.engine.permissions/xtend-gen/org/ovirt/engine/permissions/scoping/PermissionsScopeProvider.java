/**
 * generated by Xtext
 */
package org.ovirt.engine.permissions.scoping;

import com.google.common.base.Function;
import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.util.TypeReferences;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.ovirt.engine.permissions.SuppressingLinkingResource;
import org.ovirt.engine.permissions.permissions.Command;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class PermissionsScopeProvider extends AbstractDeclarativeScopeProvider {
  @Inject
  private TypeReferences typeReferences;
  
  public IScope scope_Permission_objectType(final Command ctx, final EReference r) {
    Iterable<JvmField> _declaredFields = SuppressingLinkingResource.objTypes.getDeclaredFields();
    final Function<JvmField, QualifiedName> _function = (JvmField f) -> {
      String _simpleName = f.getSimpleName();
      return QualifiedName.create(_simpleName);
    };
    return Scopes.<JvmField>scopeFor(_declaredFields, _function, IScope.NULLSCOPE);
  }
  
  public IScope scope_Permission_actionGroup(final Command ctx, final EReference r) {
    Iterable<JvmField> _declaredFields = SuppressingLinkingResource.actionGroups.getDeclaredFields();
    final Function<JvmField, QualifiedName> _function = (JvmField f) -> {
      String _simpleName = f.getSimpleName();
      return QualifiedName.create(_simpleName);
    };
    return Scopes.<JvmField>scopeFor(_declaredFields, _function, IScope.NULLSCOPE);
  }
  
  public IScope scope_Permission_condition(final Command ctx, final EReference r) {
    JvmDeclaredType _type = ctx.getType();
    Iterable<JvmOperation> _declaredOperations = _type.getDeclaredOperations();
    final Function1<JvmOperation, Boolean> _function = (JvmOperation op) -> {
      boolean _and = false;
      JvmTypeReference _returnType = op.getReturnType();
      JvmType _type_1 = _returnType.getType();
      boolean _is = this.typeReferences.is(_type_1, boolean.class);
      if (!_is) {
        _and = false;
      } else {
        EList<JvmFormalParameter> _parameters = op.getParameters();
        boolean _isEmpty = _parameters.isEmpty();
        _and = _isEmpty;
      }
      return Boolean.valueOf(_and);
    };
    Iterable<JvmOperation> _filter = IterableExtensions.<JvmOperation>filter(_declaredOperations, _function);
    final Function<JvmOperation, QualifiedName> _function_1 = (JvmOperation f) -> {
      String _simpleName = f.getSimpleName();
      return QualifiedName.create(_simpleName);
    };
    return Scopes.<JvmOperation>scopeFor(_filter, _function_1, 
      IScope.NULLSCOPE);
  }
  
  public IScope scope_Permission_objectId(final Command ctx, final EReference r) {
    JvmDeclaredType _type = ctx.getType();
    Iterable<JvmOperation> _declaredOperations = _type.getDeclaredOperations();
    final Function<JvmOperation, QualifiedName> _function = (JvmOperation f) -> {
      String _simpleName = f.getSimpleName();
      return QualifiedName.create(_simpleName);
    };
    return Scopes.<JvmOperation>scopeFor(_declaredOperations, _function, 
      IScope.NULLSCOPE);
  }
}
